** Agosto **
	- Consultados los siguientes papers:

		1. Procedural Level Design for Platform Games (2006).
		2. Modeling Player Experience in Super Mario Bros (2009).
		3. Towards Automatic Personalized Content Generation for Platform Games (2010).
		4. What is Procedural Content Generation? Mario on the borderline (2011).

	- Después de estudiarlos sabemos que hay aspectos del juego que intervienen en las emociones del jugador (diversión, desafío, frustración...).
	- El camino a seguir será codificar un algoritmo que modifique los aspectos del juego para hacer niveles atractivos al jugador.
	- Tenemos a nuestra disposición el código de Infinite Mario Bros y Mario AI, que usaremos para no tener que codificar el juego.
	- Usaremos un algoritmo genético multiobjetivo que se encargará de optimizar las distintas emociones del jugador.

** 9/9/15 **

	- Investigo la representación de niveles que se hace en Infinite Mario Bros y cómo podemos hacerlo para llevarla al algoritmo genético.

** 11/9/15 **

	- Parece ser que la clase LevelEditor es la encargada de crear el mapa. Lo hace de forma aleatoria.
	- P: ¿Cómo podemos cambiar este método para que en vez de que lo haga de forma aleatoria actuar con un genético?
	- R: Deberíamos cambiar la clase, pero primero quiero compilar el código y ver si puedo ejecutarlo.
	- Al compilarlo y colocar la clase Play como la principal obtengo un error de rutas.
	- El error proviene de la lectura de imágenes y sprites para el juego. 
	- Parece haber un problema con cómo Java calcula la ruta de un archivo, he probado con / y \ pero sigue dando error.
	- He probado a colocar los archivos en el mismo directorio desde donde se ejecuta el programa para no tener que usar ruta absoluta y parece que algunos errores se solucionan, pero sigue habiendo.

** 15/09/15 **
	
	- Se ha arreglado el error anterior localizado en LevelScene.java:596, moviendo el archivo tiles.dat al directorio classes, donde se encuentra LevelScene.java y cambiando en esa
	línea  Level.loadBehaviors(new DataInputStream(LevelScene.class.getResourceAsStream("resources/tiles.dat"))); por  Level.loadBehaviors(new DataInputStream(LevelScene.class.getResourceAsStream("tiles.dat")));

** 16/09/15 **

	- Hay que tocar en LevelGenerator.java, en el método createLevel para cambiar la distribución del nivel. Se hace en el bloque comentado en la línea 80 aproximadamente (empieza con un while).

** 23/09/15 **

	- Nuevas tareas:

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Elementos de un nivel: Elementos de estructura, enemigos

* Geometría y apariencia => SPRITES
* Atributos para el juego: Estados, damage (binario),... Ejemplo estados: TORTUGA={andando, escondida en caparazón, corriendo en caparazón}

* Un level se genera con bloques constitutivos que permiten ir construyendo el "scrolling" izquierda derecha.

* El proyecto debería considerar en todo su desarrollo la EXTENSIBILIDAD => MODULARIDAD

? Tarea1

Aclarar, mirando el código, como se construye el nivel teniendo en cuenta "elementos de estructura" y "enemigos" -> ¿Los enemigos están siempre encima de una estructura que se crea junto con ellos?

-- Respuesta: Se generan en el método addEnemyLine, que es llamado sólo cuando se necesita una línea de enemigos. Se especfica la x inicial y la final además de el valor de y.
Los sprites se crean con el método setSpriteTemplate, de la clase Level. Este último método comprueba que los valores x e y sean correctos y luego coloca el sprite en las coordenadas proporcionadas.
Se generan líneas de enemigos en la función de generación de colinas, por ejemplo: buildHillStraight llama varias veces a addEnemyLine.

La función decorate también llama a addEnemyLine, éste primera se llama en buildStraight y en buildHillStraight. Intuyo que se hace cuando queda espacio de sobra y se llama para que no quede la línea recta
del suelo sin nada más. Por tanto, los enemigos siempre se encuentran en una plataforma.

buildStraight sería equivalente a la platform de la gramática y buildHillStraight sería la hill de la gramática.

La forma en la que se distribuyen los templates por el nivel obedece a una matriz en la que en la posición x, y la ocupa el sprite que se decida colocar. Por supuesto esta matriz forma parte
del nivel explícitamente, siendo de una importancia crucial.


? Tarea2

Partiendo de la función "createLevel()" especificar donde se encuentra la información que sustenta las entidades: "elementos de estructura" y "enemigos"; son miembros dato, son variables globales, están mezcladas y repartidas entre distintos objetos de memoria...

-- Respuesta: Los bloques se crean en una función  de la clase Level, al igual que los sprites necesarios (de enemigos, flores, etc...). En la clase LevelGenerator no tenemos nada sobre estas 
entidades, toda la información se guarda en la clase Level.

Los elementos del nivel se crean con funciones, como por ejemplo las plataformas o colinas, especificando coordenadas y anchura.

Investigar dónde se especifica que se va a usar el template del cañón por ejemplo o el de los tubos.


Tarea3
Generar un nivel de prueba utilizando un genético básico.

Establecer la CORRESPONDENCIA entre la gramática de generación de niveles y la información que representa el espacio de solución del genético, así como de los algoritmos estocásticos.

Estas tres tareas proporcionan el primer HITO del proyecto. Un prototipo que se puede EVALUAR.


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

** 28/09/15 **

	- He empezado a trabajar en la codificación del algoritmo genético, apoyándome en el paper Shaker2012Evolving y en los apuntes de Metaheurísticas.
	- Hay que decidir cuál será la representación de la solución, los algoritmos de cruce, mutación y selección y el tipo de genético.

** 3/10/15 **

	- Decidida primera aproximación para la representación de la solución: Vector dinámico (mirar documento en papel).
	
** 4/10/15 **

	- Explorada la implementación de varios tipos de dato en Java para codificar el fenotipo o conjunto de soluciones del algoritmo. 
	- Se elige la implementación basada en vector estático de toda la vida, pues es la que más facilidad de acceso y manipulación da, aunque sacrificamos un poco de memoria (no demasiada).

** 5/10/15 **

	- Se empieza a codificar el genético basado en gramática. 
	- Investigar: Tipos de inicialización, elegir el más apropiado para el problema. Inicialmente se elige el más sencillo: Aleatorio.

** 6/10/15 **

	- Inicialización de la población codificada. Dejo pendiente la comprobación de restricciones: El nivel debe poder finalizarse y los elementos no sobrepasarán el ancho y alto del mismo.
	- Como cada elemento del juego tiene distintos parámetros, tenemos que diferenciar cuál de ellos es para generar números aleatorios extra -> switch.
	- La gramática no especifica los valores que toman h, w, wg y demás, deberemos ir probando.
	- Codificada parte del bucle principal del genético. Creado el documento TODO que contiene los cambios que han de ir realizándose.

** 7/10/15 **

	- Completado el esqueleto del genético básico.
	- A partir de ahora lo que resta por hacer es terminar de codificar los métodos que faltan, pero hay que tomar decisiones para construir el algoritmo.

** 8/10/15 **

	- Reunión con Alejandro. Cambiar el enfoque del genético básico:

		1. Inicializar la población con niveles que se puedan completar -> Autómata de estados que nos asegure que no se puedan insertar unos elementos después de otros de forma que el 
		nivel sea imposible de terminar (por ejemplo, después de un gap, no puede ir otro gap). Idea: Si tenemos un gap, por ejemplo, asegurar que el siguiente sea una plataforma, ya que
		será seguro que Mario puede continuar el nivel. Esto se hará de forma determinísitca usando unas reglas. En un  principio las plataformas que pueden albergar enemigos no lo harán,
		ya que de colocarlos se encarga el genético.

		2. El genético decidirá la dificultad del nivel, para ello contará el número de enemigos y su tipo. El genético sólo actuará sobre los enemigos, no las plataformas, por lo que
		los niveles serán todos finalizables. 

		3. La función fitness controla la dificultad del nivel, teniendo en cuenta el número y tipo de enemigos del mismo. Adicionalmente puede tener en cuenta dónde se sitúan (por ejemplo,
		en una colina será más difícil que una plataforma) y la dificultad del nivel (número de gaps, colinas...). Esto último es opcional y seguramente no se implemente.

** 9/10/15 **
	
	- Empezada la implementación del genético básico.
	- Cambiar el enfoque.

** 11/10/15 **

	- Parón.

** 21/11/15 **

	- El nivel ya se genera aleatoriamente, algunas recomendaciones a incluir:

		1. El nivel debería comenzar con una plataforma totalmente plana.
		2. Hay que diversificar los enemigos por el mapa (zonas de enemigos, equivalentemente).
		3. Investigar cuáles son los mejores valores para X y Param1 en los elementos del nivel, ya que algunas plataformas se aleatorizan demasiado y el resultado es bastante poco jugable.

** 30/11/15 **

	- Creada la clase GeneticLevelGenerator.java, en la que se encapsula toda la parte genética del programa.

** 20/12/15 **

	- Seguir el método de reproducción del folio:
		
		1. Añadir la estructura geneticElements al nivel.
		2. Añadir para cada elemento StraightHill un array con los argumentos de addEnemyLine, incluyendo: x0, x1, y, número de enemigos y tipo. Cambiar addEnemyLine para que tome estos datos. Generar estos datos de forma aleatoria en el método de inicialización.
		3. Al hacer la reproducción, intercambiar sólo el tipo y número de enemigos, no todo el elemento StraightHill.

	- Seguir el método de evaluación del folio:
	
		1. Hacer que el tipo de enemigos se corresponda con su dificultad: Primero el honguete, luego las tortugas...

	- Seguir el método de mutación del folio:

		1. Comprobar que los valores mutados no sean iguales a los que se tenían antes de realizar el cambio.

** 04/01/16 **

	- Métodos implementados, se empieza la fase de pruebas del algoritmo básico.
	- El método addEnemyLine se ha sobrecargado para aceptar tipo y número de enemigos, pero la posición se calcula aleatoriamente -> Debería cambiarse a como estaba antes: Colocar un enemigo cada cierto número de píxeles.
	- Mejorar o repensar el algoritmo de cruce para que intente mejorar siempre.
	- Depurar la estructura del genético y mejorar aspectos de su implementación usando el código de apoyo.

** 07/01/16 **

	- Arreglado método addEnemyLine, ahora los enemigos se colocan en intervalos regulares.
	- Estructura del algoritmo revisada, es correcta.
	- El algoritmo de cruce hace que siempre se mejore, pero la población parece estancarse según el número de iteraciones y la dificultad deseada -> ¿Se debe a que la población es muy pequeña? Probar.

** 16/01/16 **

	- Mejorar el operador de cruce para que considere elementos clave para la bondad de un nivel:

		1. Dificultad/desafío: Hay que elegir elementos que pueden hacer que el nivel sea difícil, pero no llevarlo a su más alto exponente.

			· Número y tipo de enemigos.
			· Número de "gaps" y anchura de los mismos. 
			· Frecuencia con la que Mario debe saltar (esto hace más complicado el nivel).


		2. Frustración: Si llevamos los elementos de (1) al extremo, podremos hacer que el jugador sienta frustración, no es recomendable. Además:
		
			· Número de muertes.
			· El jugador debe poder acabar el nivel en un número razonable de intentos -> Seleccionar cuidadosamente el resto de características para que esto ocurra).
			
		3. Diversión: 

			· Número y tipo de enemigos, agregar variedad -> Patear tortugas es divertido (aumentar el número de estos enemigos).
			· Monedas y mejoras que recoger. ¿Cambios de dirección?. 
			· Alternar entre andar y correr -> Crear zonas por las que el jugador pueda correr un poco.
			· Desatar una gran variedad de eventos con una acción simple.
** 19/01/16 **

	- Mayor posibilidad para generar tortugas verdes (30%) -> Influye en la DIVERSIÓN.